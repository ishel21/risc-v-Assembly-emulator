ჩემს მიერ დაწერილი ბონუს დავალება წარმოადგენს ერთგვარ ვირტუალურ მანქანას რომელიც კითხულობს და უშვებს ასემბლის ფაილებს.

დავალების შესასრულებლად გამოვიყენე პროგრამირების ენა C++ და შევქმენი კლასის Lexer "ბიბლიოთეკა" რომელიც ევალება სწორედ ასსემბლის ფაილების წაკიტხვა და გაშვება. მოცემული კლასი შედგება კონსტრუქტორის დესტრუქტორისა და ერთადერთი ფუნქციისაგან: run().

კონსტრუქტორი: Lexer("fileName")

	კონსტრუქტორს გადაეცემა იმ ფაილის სახელი რომლის გაშვებაც გვინდა, პირველ რიგში ხდება ყველა საჭირო ცვლადის შექმნა და ადგილების წინასწარ გამოყოფა, რის შემდეგაც ის ხაზ-ხაზ 	კითხულობს მოცემულ ფაილს და ამოიწერს თითოეულს, ასევე აქვე ხდება სათაურების(ლეიბლების) ჩანიშვნა შემდგომში jump-ტიპის ფუნქციები იქნას გამოძახებული.

ფუნქცია: run();

	ეს ფუნქცია არის კლასის ერთადერთი ფუნქცია რომელსაც უშვალოდ ევალება კოდის გაშვება, ის ხაზ-ხაზ გადაუყვება კოდს და ბრძანებების შესაბამის მოქმედებებს ასრულებს.

დესტრუქტორი: ~lexer();

	დესტრუქტორი უბრალოდ ასუფთავებს ჰიპში გამოყოფილ მეხსიერებას.

კლასს ზემოთ ჩამოთვლილი public ველების გარდა აქვს ცვლადები რომლებიც გამოიყენება კოდის გაშვებისთვის და წარმოადგენენ ნამდვილი პროცესორის ვირტუალურ ანალოგს:

	ვეცტორი script რომელიც გამოიყენება უშვალოდ გასაშვები კოდის სესანახად;
	მეპი labels რომელშიც შენახულია ლეიბლები ხაზის ნომრებით მათზე გადასახტომად;
	stack ფოინთერი რომელიც მიუთითებს ჰიპში გამოყოფილ მეხსიერებაზე რომელიც სტაკის ანალოგია
	მასივი registers რომელიც ნამდვილი 32 რეგისტრის ანალოგია და აქაც გათვალისწინებულია სპეციალური რეგისტრები x0-0, x1-ra, x2-sp;
	ინტი main რომელიც უბრალოდ ინახავს მთავარი კოდის დასაწყისის ნომერს (ეს არ არის მთლად აუცილებელი რადგან ლეიბლების მაპში იგივე ინფორმაცია მაინც ინახება).

ბრძანებების ჩამონათვალი რომლებიც იცის Lexer-მა:
	ecall,
	li,
	add, addi,
	mul, muli
	sub, subi,
	dev, devi,
	sw, sh, sb,
	lw, lh, lb,
	j, call, jal, jr, jalr, ret,
	mv,
	beq, bne, blt, bge, bgt, ble.

შენიშვნები:
	მოცემული კლასი გატვლილია ესემბლის კოდზე რომელშიც არ გამოიყენება მძიმეები არგუმენტებს შორის და კოდის კორექტულად გასაშვებად საჭიროა მისი მძიმეების გარეშე დაწერა;
	პროგრამა მუშაობს მხოლოდ დაბალ რეგისტრში დაწერილ ბრძანებებთან რომლებიც ჩამოთვლილია მაღლა ასე რომ მაღალ რეგისტრში დაწერილი ბრძანებები არ აღიქმება;
	პროგრამაში არ არის გათვალისწინებული ტაბების ან რამოდენიმე სფეისის ერთდროული გამოყენება ამიტომ მნიშვნელოვანია ტაბულაციის დაცვა და ბრძანების ხაზის პირველივე სიმბოლოდან წერა;
	დაბეჭდვის ბრძანება რეალიზებულია ecall-ის საშვალებით, როცა მე-10 რეგისტრში წერია 1 იბეჭდება მე-11 რეგისტრის შიგთავსი, ხოლო როცა მე-10 რეგისტრში წერია 10 კოდი სხულდება;

ტესტირება:
	main.cpp ფაილში დაინქლუდებულია მოცემული ბიბლიოთეკა და გამოიძახება 9 განსხვავებულ ტესტზე, მათ გასაშვებად საჭიროა სწორედ main.cpp ფაილის გაშვება, ახალი ტესტების დასამატებლად შეგიძლიათ გამოიყენოთ ისევ მეინ ფაილი სადაც დატოვებული მაქვს მოსახერხებელი შაბლონი, ან ნებისმიერ cpp ფაილში დააინქლუდოთ ჩემი ბიბლიოთეკა და გამოიძახოთ თქვენთვის საჭირო ტესტებზე.



